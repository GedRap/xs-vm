{"name":"xs-vm","tagline":"eXtremely small virtual machine written in Python","body":"# xs-vm [![Build Status](https://travis-ci.org/GedRap/xs-vm.svg)](https://travis-ci.org/GedRap/xs-vm)\r\n## eXtremely Simple Virtual Machine\r\n\r\nThe purpose of this project is to implement a simple virtual machine, capable of executing assembly code similar to ARM.\r\nI will keep it simple (so probably no operation modes, interrupt handling, etc) because I built it for educational\r\n purposes. Why Python? Development speed, as opposed to performance, is the key priority for this project so Python\r\n fits in perfectly.\r\n \r\n## Installing and running\r\n \r\n### Executing code\r\n\r\n```\r\n$ cat demos/function_call.s\r\nmov r1, #1\r\nmov r2, #3\r\nbl func1\r\nswi #0\r\n\r\nfunc1    push lr\r\n         add r0, r1, r2\r\n         \r\n$ python run.py demos/function_call.s\r\nInstructions executed: 7\r\nInstructions executed by type:\r\n╒═══════════════╤═════════╤═══════════════╤═════════╕\r\n│ Instruction   │   Count │ Instruction   │   Count │\r\n╞═══════════════╪═════════╪═══════════════╪═════════╡\r\n│ swi           │       1 │ bl            │       1 │\r\n├───────────────┼─────────┼───────────────┼─────────┤\r\n│ mov           │       2 │ pop           │       1 │\r\n├───────────────┼─────────┼───────────────┼─────────┤\r\n│ add           │       1 │ push          │       1 │\r\n╘═══════════════╧═════════╧═══════════════╧═════════╛\r\nRegister bank after halting:\r\n╒═════╤═══╤═════╤══════════╕\r\n│ r0  │ 4 │ r1  │        1 │\r\n├─────┼───┼─────┼──────────┤\r\n│ r2  │ 3 │ r3  │        0 │\r\n├─────┼───┼─────┼──────────┤\r\n│ r4  │ 0 │ r5  │        0 │\r\n├─────┼───┼─────┼──────────┤\r\n│ r6  │ 0 │ r7  │        0 │\r\n├─────┼───┼─────┼──────────┤\r\n│ r8  │ 0 │ r9  │        0 │\r\n├─────┼───┼─────┼──────────┤\r\n│ r10 │ 0 │ r11 │        0 │\r\n├─────┼───┼─────┼──────────┤\r\n│ r12 │ 0 │ r13 │ 16777215 │\r\n├─────┼───┼─────┼──────────┤\r\n│ r14 │ 3 │ r15 │        4 │\r\n╘═════╧═══╧═════╧══════════╛\r\n```\r\n\r\n### Installing and running tests\r\n\r\nJust clone this repository and install the dependencies (`pip install -r requirements.txt`).\r\n\r\nYou can run the tests simply by running `nosetests` from the project root directory.\r\n\r\n## Architecture\r\n\r\nThe VM has 16 registers (R0-R15). Most of the are general purpose, with a few special ones:\r\n\r\n* SP (R13). Stack pointer. Points to the last element pushed to the stack (or 0xFFFFFF if nothing has been pushed yet).\r\n\r\n* LR (R14). Link register. Holds a return address of the function call.\r\n\r\n* PC (R15). Program counter. Holds the address of the instruction in memory which will be executed next.\r\n\r\nFor function calls, the result is stored in R0, and R1-R3 are normally used to pass the parameters.\r\n\r\n### Supported instructions\r\n\r\n| Instruction | Example            | Description                                                                       |\r\n|-------------|--------------------|-----------------------------------------------------------------------------------|\r\n| mov         | mov r1, #5         | Move some value (either other register or a constant) to the register.            |\r\n|             | mov r1, r2         |                                                                                   |\r\n| add         | add r0, r1, #3     | r0 = r1 + 3                                                                       |\r\n| sub         | sub r0, r1, #3     | r0 = r1 - 3                                                                       |\r\n| mul         | mul r0, r1, #4     | r0 = r1 * 4                                                                       |\r\n| mla         | mla r0, r1, #3, #5 | r0 = r1 * 3 + 5                                                                   |\r\n| cmp         | cmp r0, r1         | Compare 2 numerical values and store the difference in comparison register (comp_reg = r0 - r1). The value is used later for conditional branching. |\r\n| b           | b main             | Always branch. Set PC to the instruction to which the given label is pointing to. |\r\n|             | b 0x001            | Instead of label, memory location can be also passed.                             |\r\n| beq         | beq main           | Branch if equal, the result of cmp instruction is used.                           |\r\n| bne         | bne main           | Branch if not equal.                                                              |\r\n| blt         | blt foo            | Branch if less than (comp_reg < 0).                                               |\r\n| bgt         | bgt foo            | Branch if greater than (comp_reg > 0).                                            |\r\n| bl          | bl printf          | Branch and link. Stores PC in LR, equivalent of a function call.                  |\r\n| nop         | nop                | No OPeration. Do nothing.                                                         |\r\n| push        | push r0            | Push the value of r0 to the stack.                                                |\r\n| pop         | pop r1             | Pop the element from the stack and store the value in r1.                         |\r\n| swi         | swi #0             | Software interrupt. See below.                                                    |\r\n\r\n#### Software interrupts\r\n\r\nIn xs-vm, software interrupts is a method of communication between the application being executed and the virtual \r\nmachine executing it.\r\n\r\nThe list of supported software interrupts:\r\n\r\n| Interrupt | Description                                   |\r\n|-----------|-----------------------------------------------|\r\n| swi #0    | Halt. Stop executing the application and quit |\r\n","google":"UA-42754612-4","note":"Don't delete this file! It's used internally to help with page regeneration."}